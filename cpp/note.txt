常量表达式(constexpr)
	常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。
	
	允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。
	
vector
	定义与初始化
		vector<T> v1
		vector<T> v2(v1)
		vector<T> v2 = v1
		vector<T> v3(n,val)
		vector<T> v4(n)
		vector<T> v5{a,b,c}
		vector<T> v5 = {a,b,c}
	vector支持的操作
		v.empty()
		v.size()
		v.push_back()
		v[n]
		v1 = v2           用v2中的元素拷贝替换v1中的元素
		v1 == v2          v1 和 v2 相等当且仅当他们的元素属相相同且对应位置的元素值都相同
		v1 ！= v2         
		< <= > >=         按字典顺序比较
		
迭代器
	但凡使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。
	
数组
	数组声明时，维度必须是一个常量表达式。
	・	constexpr unsigned sz = 42；
		int arr[sz];
		
	字符数据可以用字符串字面值初始化，字符串字面值的结尾处还有一个空字符
		char a[4] = "abc";
		
	不能将数组的内容拷贝给其他数组作为其初始值。
	
	复杂数组声明
		int *ptrs[10]             //ptrs是含有10个整型指针的数组
		int &refs[10]             //错误：不存在引用的数组
		int (*pArr)[10] = &arr;   //pArr指向一个含有10个整数的数组
		int (&arrRef)[10] = arr;  //arrRef引用一个含有10个整数的数组
		int *(&arry)[10] = ptrs;  //arry是数组的引用，该数组含有10个指针
		
	尾指针指向最后一个元素的下一个元素，但不能解引用。
	
	下标和指针：
		int *p = &ia[2];
		int k = p[-2];   //p[-2]是ia[0]表示的那个元素。
		内置的下标运算符所用的索引值不是无符号类型，与vector和string不一样。
		
	遍历二维数组：外层需使用引用
		for(const auto &row : ia)
			for(auto col : row)
				cout << col << endl;
		外层循环的控制变量需声明为引用类型，这是为了避免数组被自动转换成指针，如果不使用引用，编译器会转化成指向数组内收元素的指针。
		
	使用指针遍历二维数组
		for (auto p = a; p != a + 3; p++) {
			for (auto q = *p; q != *p + 3; q++) {
				cout << *q << ' ';
			}
			cout << std::endl;
		}
		
表达式
	左值和右值
		一个对象被用作右值，用的是对象的值(内容)；一个对象被用作左值，用的是对象在内存中的位置。
		
	求值顺序
		有4种运算符明确规定了求值顺序(&& , || , ?: , ,)
		
		对于没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义行为
			int i= 0；
			cout << i << " " << ++i <<endl;  // 未定义
			
	sizeof
		对char执行，结果为1
		对引用类型执行，得到被引用对象所占空间的大小
		对指针执行，得到指针本身占用空间大小
		对解引用执行，得到指针指向的对象所占空间的大小，指针不需要有效
		对数组执行，得到整个数组所占空间大小，等价于对数组中每个元素求sizeof求和
		对string或vector执行，返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间
		
	算数转换：
		运算符的运算对象将转换成最宽的类型。
		
		
	
		
	
		
		
		
	
	
	
	
	
		
	