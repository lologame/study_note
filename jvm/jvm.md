# JVM

## 内存区域与内存溢出异常

### 运行时数据区域

![jvm_process_data_area](./img/jvm_processing_data_area.png)

* 程序计数器

  通过改变这个计数器的值来选取下一条需要执行的字节码指令。

  每条线程都需要有一个独立的程序计数器。

* JVM栈

  JVM栈是线程私有的。

  虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个**栈帧**用于<u>存储局部变量表</u>、<u>操作数栈</u>、<u>动态链接</u>、<u>方法出口</u>等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出
  栈的过程。

  局部变量表存放了编译期可知的各种基本数据类型）、对象引用和returnAddress类型（指向了一条字节码指令的地址）。

  StackOverflowError异常:线程请求的栈深度大于虚拟机所允许的深度.

  OutOfMemoryError异常:虚拟机栈扩展时无法申请到足够的内存.

* 本地方法栈

  本地方法栈则为虚拟机使用到的Native方法服务.

* 堆

  Java堆是被所有线程共享的一块内存区域。

  所有的对象实例以及数组都要在堆上分配[。

* 方法区

  各个线程共享的内存区域。

  用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

* 运行时常量池

  运行时常量池（Runtime Constant Pool）是方法区的一部分。

  Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。


### 虚拟机对象

* 对象的创建

  1. 检查new指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
  2. 在类加载检查通过后，虚拟机将为新生对象分配内存。
  3. 将分配到的内存空间都初始化为零值。
  4. 设置对象头(对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息)。
  5. 执行＜init＞方法。

* 对象的内存布局

  对象在内存中存储的布局可以分为3块区域：<u>对象头</u>（Header）、<u>实例数据</u>（Instance Data）和对齐填充。

  **对象头**包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等;对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。

  **实例数据**部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。

* 对象的访问定位

  程序需要通过栈上的reference数据来操作堆上的具体对象。

  **句柄访问**：Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。

  ![visit_by_handle](./img/visit_by_handle.png)

  **指针访问**：reference中存储的直接就是对象地址。

  ![visit_by_pointer](./img/visit_by_pointer.png)

## GC

### 可达性分析算法

* 基本思路

  通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

* 可作为GC Roots的对象

  虚拟机栈（栈帧中的本地变量表）中引用的对象。

  方法区中类静态属性引用的对象。

  方法区中常量引用的对象。

  本地方法栈中JNI（即一般说的Native方法）引用的对象。

### 引用

* 强引用

* 软引用

  在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。

* 弱引用

  被弱引用关联的对象只能生存到下一次垃圾收集发生之前。

* 虚引用

  为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

  一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。


### 回收对象

1. 判断是否有与GC Roots相连的引用链。

2. 判断此对象的finalize方法是否有必要执行。

   一个对象的finalize 方法只会执行一次。

### 回收方法区 

* 回收常量条件

  无任何引用时回收

* 回收废弃类条件

  1. 该类所有的实例都已经被回收。
  2. 加载该类的ClassLoader已经被回收。
  3. 该类对应的java.lang.Class对象没有在任何地方被引用。

### 垃圾收集算法

* 标记-清除算法

* 复制算法

  将内存分为两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，，然后再把已使用过的内存空间一次清理掉。

* 标记-整理算法

  让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

* 分代收集算法

  在新生代中使用复制算法，在老年代中使用标记-清除算法或标记-整理算法。

精确式GC与保守式GC

* 精确式GC：回收过程中能准确的识别和回收每一个无用对象，为了准确识别每一个对象的引用，通常要求一些额外的数据。
* 保守式GC：不能准确的识别每一个无用对象。

### HotSpot的算法实现

* 枚举根节点

  可达性分析产生GC停顿。

  使用OopMap的数据结构得知对象引用的存放位置。

  因为使用准确式GC，故而不需要检查完所有执行上下文和全局的引用位置。

* 安全点(进入GC的点)

  抢险式中断：首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。

  主动式中断：设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的。

* 安全区域

  代码段中引用关系不会发生变化的区域。

### 垃圾收集器

* Serial收集器

  ![serial_gc](./img/serial_gc.png)

* ParNew收集器

  Serial收集器的多线程版本。

* Parallel Scavenge收集器

  吞吐量优先的ParNew收集器，能够自适应调节分代比例等参数以获取最大的吞吐量。是复制算法使用的收集器。

* CMS收集器

  基于标记-清除算法实现。

  ![cms_gc](./img/cms_gc.png)

  * 初始标记:标记GC Roots能直接关联到的对象.
  * 并发标记:进行GC RootsTracing的过程.
  * 重新标记:修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录.

  缺点：

  1. 增大CPU负荷，占用线程，导致应用程序运行变慢。
  2. 无法处理"浮动垃圾"，必须预留内存供用户线程使用。
  3. 可能导致大量空间碎片。

* G1

  ![g1_gc](./img/g1_gc.png)

### 内存分配与回收策略

* 对象优先分配在新生代的Eden区

* 大对象直接进入老年代

* 长期存活的对象将进入老年代

  对象在Eden区中经历第一次Minor GC，将被移动到Survivor区中，并将年龄设置为1，之后每经历一次Minor GC，年龄加1。

* 动态的对象年龄判定

  如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。

* 空间分配担保

  在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。

  当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要
  老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。


## 类文件结构

### 无关性

JVM提供的语言无关性支持。JVM只关心class文件，不关心来源于何种语言。

### 类文件结构

* 魔数与Class文件的版本(前8个字节)

* 常量池

  在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的		  话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。

  常量池项目类型：

  ![constant_pool_item_type](./img/constant_pool_item_type.png)



* 访问标志：常量池结束后的两个字节。

* 类索引、父类索引、接口索引集合

* 字段表集合

* 字段表结构

  ![field_info_structure](./img/field_info_structure.png)

* 方法表集合

* 属性表集合

  虚拟机规范中的常用预定义属性

  ![attribute_info_structure](./img/attribute_info_structure.png)

  * Code属性：Java程序方法体中的代码经过Javac编译器处理后，最终变为字节码指令存储在Code属性内。
  * Exceptions属性：列举出方法中可能抛出的受查异常。
  * LineNumberTable属性：于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。
  * LocalVaribleTable属性：描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系。
  * SourceFile属性：用于记录生成这个Class文件的源码文件名称。
  * InnerClasses属性：用于记录内部类与宿主类之间的关联。
  * Signature属性：任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则Signature属性会为它记录泛型签名信息。反射API能够获取泛型类型，最终的数据来源就是这个属性。


### 字节码指令

JVM指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构成。由于JVM采用面向操作数栈的架构，所以大多数的指令都不包含操作数，只有一个操作码。


























